# -*- coding: utf-8 -*-
u"""Guess the natural language of a text
"""
#   © 2012 spirit <hiddenspirit@gmail.com>
#   https://bitbucket.org/spirit/guess_language
#
#   Original Python package:
#   Copyright (c) 2008, Kent S Johnson
#   http://code.google.com/p/guess-language/
#
#   Original C++ version for KDE:
#   Copyright (c) 2006 Jacob R Rideout <kde@jacobrideout.net>
#   http://websvn.kde.org/branches/work/sonnet-refactoring/common/nlp/guesslanguage.cpp?view=markup
#
#   Original Language::Guess Perl module:
#   Copyright (c) 2004-2006 Maciej Ceglowski
#   http://web.archive.org/web/20090228163219/http://languid.cantbedone.org/
#
#   Note: Language::Guess is GPL-licensed. KDE developers received permission
#   from the author to distribute their port under LGPL:
#   http://lists.kde.org/?l=kde-sonnet&m=116910092228811&w=2
#
#   This program is free software: you can redistribute it and/or modify it
#   under the terms of the GNU Lesser General Public License as published
#   by the Free Software Foundation, either version 3 of the License,
#   or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty
#   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#   See the GNU Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public License
#   along with this program. If not, see <http://www.gnu.org/licenses/>.

from __future__ import division
from __future__ import absolute_import
import functools
import re
import warnings

from collections import defaultdict, OrderedDict

from .data import BLOCKS, BLOCK_RSHIFT


__all__ = [
    u"guess_language", u"use_enchant",
]

MAX_LENGTH = 4096
MIN_LENGTH = 20
MAX_GRAMS = 300
WORD_RE = re.compile(ur"(?:[^\W\d_]|['’])+", re.U)
MODEL_ROOT = __name__ + u".data.models."
FALLBACK_LANGUAGE = u"en_US"

BASIC_LATIN = set([
    u"ceb", u"en", u"eu", u"ha", u"haw", u"id", u"la", u"nr", u"nso", u"so", u"ss", u"st",
    u"sw", u"tlh", u"tn", u"ts", u"xh", u"zu"])
EXTENDED_LATIN = set([
    u"af", u"az", u"ca", u"cs", u"cy", u"da", u"de", u"eo", u"es", u"et", u"fi", u"fr",
    u"hr", u"hu", u"is", u"it", u"lt", u"lv", u"nb", u"nl", u"pl", u"pt", u"ro", u"sk",
    u"sl", u"sq", u"sv", u"tl", u"tr", u"ve", u"vi"])
ALL_LATIN = BASIC_LATIN.union(EXTENDED_LATIN)
CYRILLIC = set([u"bg", u"kk", u"ky", u"mk", u"mn", u"ru", u"sr", u"uk", u"uz"])
ARABIC = set([u"ar", u"fa", u"ps", u"ur"])
DEVANAGARI = set([u"hi", u"ne"])
PT = set([u"pt_BR", u"pt_PT"])

# NOTE mn appears twice, once for mongolian script and once for CYRILLIC
SINGLETONS = [
    (u"Armenian", u"hy"),
    (u"Hebrew", u"he"),
    (u"Bengali", u"bn"),
    (u"Gurmukhi", u"pa"),
    (u"Greek", u"el"),
    (u"Gujarati", u"gu"),
    (u"Oriya", u"or"),
    (u"Tamil", u"ta"),
    (u"Telugu", u"te"),
    (u"Kannada", u"kn"),
    (u"Malayalam", u"ml"),
    (u"Sinhala", u"si"),
    (u"Thai", u"th"),
    (u"Lao", u"lo"),
    (u"Tibetan", u"bo"),
    (u"Burmese", u"my"),
    (u"Georgian", u"ka"),
    (u"Mongolian", u"mn-Mong"),
    (u"Khmer", u"km"),
]

NAME_MAP = {
    u"ab": u"Abkhazian",
    u"af": u"Afrikaans",
    u"ar": u"Arabic",
    u"az": u"Azeri",
    u"be": u"Byelorussian",
    u"bg": u"Bulgarian",
    u"bn": u"Bengali",
    u"bo": u"Tibetan",
    u"br": u"Breton",
    u"ca": u"Catalan",
    u"ceb": u"Cebuano",
    u"cs": u"Czech",
    u"cy": u"Welsh",
    u"da": u"Danish",
    u"de": u"German",
    u"el": u"Greek",
    u"en": u"English",
    u"eo": u"Esperanto",
    u"es": u"Spanish",
    u"et": u"Estonian",
    u"eu": u"Basque",
    u"fa": u"Farsi",
    u"fi": u"Finnish",
    u"fo": u"Faroese",
    u"fr": u"French",
    u"fy": u"Frisian",
    u"gd": u"Scots Gaelic",
    u"gl": u"Galician",
    u"gu": u"Gujarati",
    u"ha": u"Hausa",
    u"haw": u"Hawaiian",
    u"he": u"Hebrew",
    u"hi": u"Hindi",
    u"hr": u"Croatian",
    u"hu": u"Hungarian",
    u"hy": u"Armenian",
    u"id": u"Indonesian",
    u"is": u"Icelandic",
    u"it": u"Italian",
    u"ja": u"Japanese",
    u"ka": u"Georgian",
    u"kk": u"Kazakh",
    u"km": u"Cambodian",
    u"ko": u"Korean",
    u"ku": u"Kurdish",
    u"ky": u"Kyrgyz",
    u"la": u"Latin",
    u"lt": u"Lithuanian",
    u"lv": u"Latvian",
    u"mg": u"Malagasy",
    u"mk": u"Macedonian",
    u"ml": u"Malayalam",
    u"mn": u"Mongolian",
    u"mr": u"Marathi",
    u"ms": u"Malay",
    u"nd": u"Ndebele",
    u"ne": u"Nepali",
    u"nl": u"Dutch",
    u"nn": u"Nynorsk",
    u"no": u"Norwegian",
    u"nso": u"Sepedi",
    u"pa": u"Punjabi",
    u"pl": u"Polish",
    u"ps": u"Pashto",
    u"pt": u"Portuguese",
    u"pt_PT": u"Portuguese (Portugal)",
    u"pt_BR": u"Portuguese (Brazil)",
    u"ro": u"Romanian",
    u"ru": u"Russian",
    u"sa": u"Sanskrit",
    u"sh": u"Serbo-Croatian",
    u"sk": u"Slovak",
    u"sl": u"Slovene",
    u"so": u"Somali",
    u"sq": u"Albanian",
    u"sr": u"Serbian",
    u"sv": u"Swedish",
    u"sw": u"Swahili",
    u"ta": u"Tamil",
    u"te": u"Telugu",
    u"th": u"Thai",
    u"tl": u"Tagalog",
    u"tlh": u"Klingon",
    u"tn": u"Setswana",
    u"tr": u"Turkish",
    u"ts": u"Tsonga",
    u"tw": u"Twi",
    u"uk": u"Ukrainian",
    u"ur": u"Urdu",
    u"uz": u"Uzbek",
    u"ve": u"Venda",
    u"vi": u"Vietnamese",
    u"xh": u"Xhosa",
    u"zh": u"Chinese",
    u"zh_TW": u"Traditional Chinese (Taiwan)",
    u"zu": u"Zulu",
}

IANA_MAP = {
    u"ab": 12026,
    u"af": 40,
    u"ar": 26020,
    u"az": 26030,
    u"be": 11890,
    u"bg": 26050,
    u"bn": 26040,
    u"bo": 26601,
    u"br": 1361,
    u"ca": 3,
    u"ceb": 26060,
    u"cs": 26080,
    u"cy": 26560,
    u"da": 26090,
    u"de": 26160,
    u"el": 26165,
    u"en": 26110,
    u"eo": 11933,
    u"es": 26460,
    u"et": 26120,
    u"eu": 1232,
    u"fa": 26130,
    u"fi": 26140,
    u"fo": 11817,
    u"fr": 26150,
    u"fy": 1353,
    u"gd": 65555,
    u"gl": 1252,
    u"gu": 26599,
    u"ha": 26170,
    u"haw": 26180,
    u"he": 26592,
    u"hi": 26190,
    u"hr": 26070,
    u"hu": 26200,
    u"hy": 26597,
    u"id": 26220,
    u"is": 26210,
    u"it": 26230,
    u"ja": 26235,
    u"ka": 26600,
    u"kk": 26240,
    u"km": 1222,
    u"ko": 26255,
    u"ku": 11815,
    u"ky": 26260,
    u"la": 26280,
    u"lt": 26300,
    u"lv": 26290,
    u"mg": 1362,
    u"mk": 26310,
    u"ml": 26598,
    u"mn": 26320,
    u"mr": 1201,
    u"ms": 1147,
    u"ne": 26330,
    u"nl": 26100,
    u"nn": 172,
    u"no": 26340,
    u"pa": 65550,
    u"pl": 26380,
    u"ps": 26350,
    u"pt": 26390,
    u"ro": 26400,
    u"ru": 26410,
    u"sa": 1500,
    u"sh": 1399,
    u"sk": 26430,
    u"sl": 26440,
    u"so": 26450,
    u"sq": 26010,
    u"sr": 26420,
    u"sv": 26480,
    u"sw": 26470,
    u"ta": 26595,
    u"te": 26596,
    u"th": 26594,
    u"tl": 26490,
    u"tlh": 26250,
    u"tn": 65578,
    u"tr": 26500,
    u"tw": 1499,
    u"uk": 26520,
    u"ur": 26530,
    u"uz": 26540,
    u"vi": 26550,
    u"zh": 26065,
    u"zh_TW": 22,
}

models = {}

try:
    from importlib import import_module
except ImportError:
    import sys

    def import_module(name):
        u"""Import a module.
        """
        __import__(name)
        return sys.modules[name]

try:
    from collections import namedtuple

    LanguageInfo = namedtuple(u"LanguageInfo", [u"tag", u"id", u"name"])
except ImportError:
    class LanguageInfo(tuple):
        def __new__(cls, tag, id, name): #@ReservedAssignment
            return tuple.__new__(cls, (tag, id, name))

        def __init__(self, tag, id, name): #@ReservedAssignment
            self.tag = tag
            self.id = id
            self.name = name


class UNKNOWN(unicode):
    u"""Unknown language
    """
    def __nonzero__(self):
        return False


UNKNOWN = UNKNOWN(u"UNKNOWN")


def guess_language(text, hints=None):
    u"""Return the ISO 639-1 language code.
    """
    words = WORD_RE.findall(text[:MAX_LENGTH].replace(u"’", u"'"))
    return identify(words, find_runs(words), hints)


def guess_language_info(text, hints=None):
    u"""Return LanguageInfo(tag, id, name).
    """
    tag = guess_language(text, hints)

    if tag is UNKNOWN:
        return LanguageInfo(UNKNOWN, UNKNOWN, UNKNOWN)

    return LanguageInfo(tag, _get_id(tag), _get_name(tag))


# An alias for guess_language
guess_language_tag = guess_language


def guess_language_id(text, hints=None):
    u"""Return the language ID.
    """
    return _get_id(guess_language(text, hints))


def guess_language_name(text, hints=None):
    u"""Return the language name (in English).
    """
    return _get_name(guess_language(text, hints))


def _get_id(tag):
    return IANA_MAP.get(tag, UNKNOWN)


def _get_name(tag):
    return NAME_MAP.get(tag, UNKNOWN)


def find_runs(words):
    u"""Count the number of characters in each character block.
    """
    run_types = defaultdict(int)

    total_count = 0

    for word in words:
        for char in word:
            block = BLOCKS[ord(char) >> BLOCK_RSHIFT]
            run_types[block] += 1
            total_count += 1

    #pprint(run_types)

    # return run types that used for 40% or more of the string
    # return Basic Latin if found more than 15%
    ## and extended additional latin if over 10% (for Vietnamese)
    relevant_runs = []
    for key, value in run_types.items():
        pct = value * 100 // total_count
        if pct >= 40 or pct >= 15 and key == u"Basic Latin":
            relevant_runs.append(key)
        #elif pct >= 10 and key == "Latin Extended Additional":
            #relevant_runs.append(key)

    return relevant_runs


def identify(words, scripts, hints=None):
    u"""Identify the language.
    """
    if (u"Hangul Syllables" in scripts or u"Hangul Jamo" in scripts or
            u"Hangul Compatibility Jamo" in scripts or u"Hangul" in scripts):
        return u"ko"

    if u"Greek and Coptic" in scripts:
        return u"el"

    if u"Kana" in scripts:
        return u"ja"

    if (u"CJK Unified Ideographs" in scripts or u"Bopomofo" in scripts or
            u"Bopomofo Extended" in scripts or u"KangXi Radicals" in scripts):
# This is in both Ceglowski and Rideout
# I can't imagine why...
#            or "Arabic Presentation Forms-A" in scripts
        return u"zh"

    if u"Cyrillic" in scripts:
        return check(words, filter_languages(CYRILLIC, hints))

    if (u"Arabic" in scripts or u"Arabic Presentation Forms-A" in scripts or
            u"Arabic Presentation Forms-B" in scripts):
        return check(words, filter_languages(ARABIC, hints))

    if u"Devanagari" in scripts:
        return check(words, filter_languages(DEVANAGARI, hints))

    # Try languages with unique scripts
    for block_name, lang_name in SINGLETONS:
        if block_name in scripts:
            return lang_name

    #if "Latin Extended Additional" in scripts:
        #return "vi"

    if u"Extended Latin" in scripts:
        latin_lang = check(words, filter_languages(EXTENDED_LATIN, hints))
        if latin_lang == u"pt":
            return check(words, filter_languages(PT))
        else:
            return latin_lang

    if u"Basic Latin" in scripts:
        return check(words, filter_languages(ALL_LATIN, hints))

    return UNKNOWN


def filter_languages(languages, hints=None):
    u"""Filter languages.
    """
    return languages.intersection(hints) if hints else languages


def check_with_all(words, languages):
    u"""Check what the best match is.
    """
    return (check_with_enchant(words, languages) or
            check_with_models(words, languages))


check = check_with_all


def use_enchant(use_enchant=True):
    u"""Enable or disable checking with PyEnchant.
    """
    global check
    check = check_with_all if use_enchant else check_with_models


def check_with_models(words, languages):
    u"""Check against known models.
    """
    sample = u" ".join(words)

    if len(sample) < MIN_LENGTH:
        return UNKNOWN

    scores = []
    model = create_ordered_model(sample)  # QMap<int,QString>

    for key in languages:
        lkey = key.lower()

        try:
            known_model = models[lkey]
        except KeyError:
            try:
                known_model = import_module(MODEL_ROOT + lkey).model
            except ImportError:
                known_model = None
            models[lkey] = known_model

        if known_model:
            scores.append((distance(model, known_model), key))

    if not scores:
        return UNKNOWN

    # we want the lowest score, less distance = greater chance of match
    #pprint(sorted(scores))
    return min(scores)[1]


def create_ordered_model(content):
    u"""Create a list of trigrams in content sorted by frequency.
    """
    trigrams = defaultdict(int)  # QHash<QString,int>
    content = content.lower()

    for i in xrange(len(content) - 2):
        trigrams[content[i:i+3]] += 1

    return sorted(trigrams.keys(), key=lambda k: (-trigrams[k], k))


def distance(model, known_model):
    u"""Calculate the distance to the known model.
    """
    dist = 0

    for i, value in enumerate(model[:MAX_GRAMS]):
        if value in known_model:
            dist += abs(i - known_model[value])
        else:
            dist += MAX_GRAMS

    return dist


try:
    import enchant
except ImportError:
    warnings.warn(u"PyEnchant is unavailable", ImportWarning)
    enchant = None

    def check_with_enchant(*args, **kwargs):
        return UNKNOWN
else:
    import locale

    enchant_base_languages_dict = None

    def check_with_enchant(words, languages,
                           threshold=0.7, min_words=1, dictionaries={}):
        u"""Check against installed spelling dictionaries.
        """
        if len(words) < min_words:
            return UNKNOWN

        best_score = 0
        best_tag = UNKNOWN

        for tag, enchant_tag in get_enchant_base_languages_dict().items():
            if tag not in languages:
                continue
            try:
                d = dictionaries[tag]
            except KeyError:
                d = dictionaries[tag] = enchant.Dict(enchant_tag)
            score = sum([1 for word in words if d.check(word)])
            if score > best_score:
                best_score = score
                best_tag = tag

        if best_score / len(words) < threshold:
            return UNKNOWN

        return best_tag

    def get_enchant_base_languages_dict():
        u"""Get ordered dictionary of enchant base languages.

        locale_language, then "en", then the rest.
        """
        global enchant_base_languages_dict
        if enchant_base_languages_dict is None:
            def get_language_sub_tag(tag):
                return tag.split(u"_")[0]
            enchant_base_languages_dict = OrderedDict()
            enchant_languages = sorted(enchant.list_languages())
            for full_tag in [get_locale_language(), FALLBACK_LANGUAGE]:
                sub_tag = get_language_sub_tag(full_tag)
                if sub_tag not in enchant_base_languages_dict:
                    for tag in [full_tag, sub_tag]:
                        try:
                            index = enchant_languages.index(tag)
                        except ValueError:
                            pass
                        else:
                            enchant_base_languages_dict[sub_tag] = tag
                            del enchant_languages[index]
                            break
            for tag in enchant_languages:
                sub_tag = get_language_sub_tag(tag)
                if sub_tag not in enchant_base_languages_dict:
                    enchant_base_languages_dict[sub_tag] = tag
        return enchant_base_languages_dict

    def get_locale_language():
        u"""Get the language code for the current locale setting.
        """
        return (locale.getlocale()[0] or locale.getdefaultlocale()[0] or
                FALLBACK_LANGUAGE)


def deprecated(func):
    u"""This is a decorator which can be used to mark functions
    as deprecated. It will result in a warning being emitted
    when the function is used.
    """
    @functools.wraps(func)
    def new_func(*args, **kwargs):
        warnings.warn(
            u"call to deprecated function %s()" % func.__name__,
            category=DeprecationWarning,
            stacklevel=2
        )
        return func(*args, **kwargs)
    return new_func


@deprecated
def guessLanguage(text):
    u"""Deprecated function - use guess_language() instead.
    """
    return guess_language(decode_text(text))


@deprecated
def guessLanguageTag(text):
    u"""Deprecated function - use guess_language_tag() instead.
    """
    return guess_language_tag(decode_text(text))


@deprecated
def guessLanguageId(text):
    u"""Deprecated function - use guess_language_id() instead.
    """
    return guess_language_id(decode_text(text))


@deprecated
def guessLanguageName(text):
    u"""Deprecated function - use guess_language_name() instead.
    """
    return guess_language_name(decode_text(text))


@deprecated
def guessLanguageInfo(text):
    u"""Deprecated function - use guess_language_info() instead.
    """
    return guess_language_info(decode_text(text))


def decode_text(text, encoding=u"utf-8"):
    u"""Decode text if needed (for deprecated functions).
    """
    if not isinstance(text, unicode):
        warnings.warn(u"passing an encoded string is deprecated",
                      DeprecationWarning, 4)
        text = text.decode(encoding)
    return text
